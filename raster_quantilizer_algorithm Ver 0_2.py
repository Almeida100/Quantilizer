# -*- coding: utf-8 -*-

"""
/***************************************************************************
 RasterQuantilizer
                                 A QGIS plugin
 This plugin takes a raster whose values span a wide range, and produces a raster with only five unique values: 1, 2, 3, 4 and 5, each with the same frequency.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-04-12
        copyright            : (C) 2021 by Antonio Sobral Almeida
        email                : 66124.almeida@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Antonio Sobral Almeida'
__date__ = '2021-04-12'
__copyright__ = '(C) 2021 by Antonio Sobral Almeida'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterField
from qgis.core import QgsProcessingParameterFile
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterNumber
from qgis.core import QgsProcessingParameterRasterDestination
from qgis.core import QgsProcessingParameterFeatureSink
from qgis.core import QgsProcessingParameterVectorDestination
from qgis.core import QgsProcessingParameterCrs
from qgis.core import QgsProcessingParameterDefinition
import sys
from qgis.core import (
     QgsApplication, 
     QgsProcessingFeedback, 
     QgsVectorLayer
)
from qgis.analysis import QgsNativeAlgorithms
import time
from datetime import datetime
from qgis.core import QgsProject
import processing
import os
import numpy as np
from osgeo import gdal, gdal_array, osr

class RasterQuantilizerAlgorithm(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        # Create a time stamp
        tme=time.localtime()
        timeString=datetime.now().strftime('%d-%m-%Y-%H-%M-%S_')
        # Find processing output directory
        u_dir = QgsApplication.qgisSettingsDirPath()
        p_dir = os.path.join(u_dir,'processing/outputs')
        t_dir = p_dir+'/'+timeString
        self.t_dir = t_dir
        self.addParameter(QgsProcessingParameterRasterLayer('Inputraster', 'Input raster', defaultValue=None))
        self.addParameter(QgsProcessingParameterCrs('CRSofoutputraster', 'CRS of Output raster', defaultValue='EPSG:3763'))
        param = QgsProcessingParameterNumber('Class1ULP', 'Class1 Upper Limit Percentile', type=QgsProcessingParameterNumber.Integer, minValue=1, maxValue=99, defaultValue=20)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)        
        param = (QgsProcessingParameterNumber('Class2ULP', 'Class2 Upper Limit Percentile', type=QgsProcessingParameterNumber.Integer, minValue=1, maxValue=99, defaultValue=40))
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)         
        param = (QgsProcessingParameterNumber('Class3ULP', 'Class3 Upper Limit Percentile', type=QgsProcessingParameterNumber.Integer, minValue=1, maxValue=99, defaultValue=60))
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)         
        param = (QgsProcessingParameterNumber('Class4ULP', 'Class4 Upper Limit Percentile', type=QgsProcessingParameterNumber.Integer, minValue=1, maxValue=99, defaultValue=80))
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)         
        param = (QgsProcessingParameterNumber('Class5ULP', 'Class5 Upper Limit Percentile (Always = 100)', type=QgsProcessingParameterNumber.Integer, minValue=100, maxValue=100, defaultValue=100))
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)          
        self.addParameter(QgsProcessingParameterRasterDestination('Quantilized', 'Quantilized', createByDefault=True, defaultValue=timeString+'Quantilized.tif'))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(3, model_feedback)
        results = {}
        outputs = {}

        # Translate (convert format)
        alg_params = {
            'COPY_SUBDATASETS': False,
            'DATA_TYPE': 6,
            'EXTRA': '',
            'INPUT': parameters['Inputraster'],
            'NODATA': -99999,
            'OPTIONS': '',
            'TARGET_CRS': parameters['CRSofoutputraster'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['TranslateConvertFormat'] = processing.run('gdal:translate', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Quantile
        
        alg_params = {
            'INPUT': outputs['TranslateConvertFormat']['OUTPUT'],

            'QUANTILE': None
        }
        lname = outputs['TranslateConvertFormat']['OUTPUT']
        dataset = gdal.Open(lname)
        band = dataset.GetRasterBand(1)
        nodata = band.GetNoDataValue()
        array = dataset.ReadAsArray()

        new_array = array
        nan_array = array

        nan_array[array == nodata] = np.nan

        percentile_80 = np.nanpercentile(nan_array, parameters['Class4ULP'])
        percentile_60 = np.nanpercentile(nan_array, parameters['Class3ULP'])
        percentile_40 = np.nanpercentile(nan_array, parameters['Class2ULP'])
        percentile_20 = np.nanpercentile(nan_array, parameters['Class1ULP'])
        percentile_0 = np.nanpercentile(nan_array, 0)

        for i, v in enumerate(new_array):
            for j, element in enumerate(v):
                if element > percentile_0 and element <= percentile_20:
                    new_array[i,j] = 1
                if element > percentile_20 and element <= percentile_40:
                    new_array[i,j] = 2
                if element > percentile_40 and element <= percentile_60:
                    new_array[i,j] = 3
                if element > percentile_60 and element <= percentile_80:
                    new_array[i,j] = 4
                if element > percentile_80:
                    new_array[i,j] = 5

        new_array[ new_array != new_array ] = nodata

        geotransform = dataset.GetGeoTransform()
        wkt = dataset.GetProjection()

        # Create gtif file        
        driver = gdal.GetDriverByName("GTiff")
        resultsq = self.t_dir+'Per5ClassNODATA.tif'

        dst_ds = driver.Create(resultsq,
                               band.XSize,
                               band.YSize,
                               1,
                               gdal.GDT_Int16)

        #writting output raster
        dst_ds.GetRasterBand(1).WriteArray( new_array )
        #setting nodata value
        dst_ds.GetRasterBand(1).SetNoDataValue(nodata)
        #setting extension of output raster
        # top left x, w-e pixel resolution, rotation, top left y, rotation, n-s pixel resolution
        dst_ds.SetGeoTransform(geotransform)
        # setting spatial reference of output raster
        srs = osr.SpatialReference()
        srs.ImportFromWkt(wkt)
        dst_ds.SetProjection( srs.ExportToWkt() )
        #Close output raster dataset
        dataset = None
        dst_ds = None 
        results['quantilizearaster'] = ['QUANTILE']

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Raster calculator
        alg_params = {
            'FORMULA': 'ifelse(a=0, 0/0, ifelse(a<0, 0/0, a))',
            'GRIDS': resultsq,
            'RESAMPLING': 3,
            'TYPE': 7,
            'USE_NODATA': False,
            'XGRIDS': None,
            'RESULT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RasterCalculator'] = processing.run('saga:rastercalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Translate (convert format)
        alg_params = {
            'COPY_SUBDATASETS': False,
            'DATA_TYPE': 6,
            'EXTRA': '',
            'INPUT': outputs['RasterCalculator'] ['RESULT'],
            'NODATA': -99999,
            'OPTIONS': '',
            'TARGET_CRS': parameters['CRSofoutputraster'],
            'OUTPUT': parameters['Quantilized']
        }
        outputs['TranslateConvertFormat'] = processing.run('gdal:translate', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Quantilized'] = outputs['TranslateConvertFormat']['OUTPUT']
        return results

    def name(self):
        return 'Quantilizer'

    def displayName(self):
        return 'Raster Quantilizer Vers 0.2'

    def group(self):
        return None

    def groupId(self):
        return None

    def createInstance(self):
        return RasterQuantilizerAlgorithm()
